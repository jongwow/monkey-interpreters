# 3장

## 누가 쓰레기를 치울까

처음부터 끝까지 직접 동작하는 인터프리터를 완성했다. 하지만 한가지 고백할 점이 있다.

```
let counter = fn(x) {
	if (x > 100){
		return true;
	} else {
	let foobar = 9999;
	    counter(x + 1);
	}
}

counter(0);
```
위 Monkey 코드를 실행하면, counter의 몸체를 101번 평가 후 true를 반환. 하지만 마지막 재귀 호출 전까지 훨씬 많은 일이 일어난다.

### 현상
첫 번째 평가 대상은 if-else-표현식의 조건인 x > 100. truthy가 아니라면 <alternative>가 평가됨. 그리고 <alternative> 에서 정수 리터럴 9999는 foobar에 바인딩되지만,
결코 다시 참조될 수 없다. 그러고 나서 x+1이 평가된다. Eval 함수 호출 결과가 다음번 counter 함수를 호출할 때 인수로 사용된다. 이렇게 표현식 x > 100 이 TRUE 로 평가될 때까지 같은 동작이 반복된다.

요점을 말하자면 counter 함수를 호출할 때마다 많은 객체가 할당. Eval 함수와 우리가 정의한 객체 시스템 관점엣 ㅓ 말하면 counter 함수의 몸체를 평가할 때마다 object.Integer 객체가 다수 할당되고 초기화된다. 9999는 사용되지 않는 정수 리터럴이고 표현식 x+1 역시 할당되고 초기화된다.
심지어 정수 리터럴 100과 1 조차 counter 함수의 몸체를 평가할 때마다 새로운 object.Integer를 매번 만든다.

### 문제
- 객체는 메모리에 저장. 객체 많이 쓰니까 메모리가 부족할 것..! 
- 사실 저 monkey를 실제로 실행해보면 메모리가 늘어나지 않음.
- 늘어나야하는데 왜?
- go의 GC가 대신 메모리를 관리해주기 때문.
- GC가 접근가능한 객체와 접근가능하지않은 객체를 추적. 

만약 GC를 우리가 직접 만들어야 한다면?
1. 객체 할당 (object allocations) 추적
2. 객체 참조 (references to objects) 추적
3. 미래에 할당할 객체를 위한 충분한 메모리 확보
4. 필요 없는 객체에서 메모리 수거

여러가지 고려사항
- 알고리즘: 마크 앤 스윕, ...
- 방식: 제너레이셔널 GC, 스톱 더 월드 GC, 뱅행성 GC
- 메모리 구성 밧기
- 메모리 파편화 처리 방식
- ...
- 